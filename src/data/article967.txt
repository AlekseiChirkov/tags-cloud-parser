Автор: DAN_SEA
Дата: 2021-09-20T13:00:02.000Z
Название: Удалённое управление питанием и перезагрузкой компьютера, при помощи
внешнего девайса
Теги: Блог компании RUVDS.com, Разработка для интернета вещей *, Разработка
под Arduino *, DIY или Сделай сам, Электроника для начинающих
Текст:
Каждый пользователь компьютера сталкивался хотя бы раз в своей жизни с
такой ситуацией: ты ушёл к себе на работу, почти доехал до неё и вдруг
вспомнил,- что забыл взять со своего личного компьютера какую-то очень
важную вещь.   Ехать обратно — опоздаешь на работу. А ведь ситуация
может развиваться и гораздо более драматично: допустим, человек поехал
куда-то далеко за рубеж, в отпуск, и там ему приходит важный звонок,
по результатам которого ему необходимо передать своему визави,-
определённые документы. А документы остались дома! А дом находится за
границей!   Или вот ещё такая беда: ваш персональный компьютер
является мощной графической станцией, на которой установлено множество
тяжёлых программ для работы с графикой, программными продуктами. А вы
перемещаетесь по городу, имея в руках всего лишь «тонкий» клиент, в
виде ноутбука…   Из этого описания становится понятно, что «тонкий»
клиент не обладает соответствующей производительностью, для запуска
множества высокопрофессиональных программ и проектов. Да и если даже
он у вас достаточно мощный, — это в принципе неудобно, каждый раз
синхронизировать проекты с «тонким» клиентом. Как быть в описанных
выше ситуациях — мы и поговорим в этой статье.   На самом деле,
указанная проблема очень легко решается: установкой на ваш
персональный компьютер системы удалённого включения/выключения и
перезагрузки. Этот подход позволит всегда иметь под рукой всю мощь
вашей домашней машины и все необходимые документы, и проекты,
хранящиеся на ней.    До начала описания своей разработки, хочу
сказать, что конечно, она не является единственно возможным способом
для удалённого включения выключенного компьютера. Например, хорошо
известна технология Wake-on-LAN. Суть этой технологии заключается в
том, что она позволяет включить выключенный компьютер, отправкой
специального пакета на его MAC-адрес.   Сетевой адаптер компьютера,
поддерживающего Wake-on-LAN, находится в этот момент в режиме
пониженного потребления и анализирует все пакеты на него. Если одним
из поступающих пакетов окажется так называемый magic packet, сетевой
адаптер выдаст сигнал на включение питания компьютера. Согласно wiki:
Magic packet — это специальная последовательность байтов, которую для
нормального прохождения по локальным сетям можно вставить в пакеты
транспортного уровня, не требующие установки соединения (например,
протокол UDP или устаревший IPX). Обычно для Wake-on-LAN пакеты
протоколов верхнего уровня рассылают широковещательно, так как в
случае динамического присвоения адресов неизвестно, какой IP-адрес
соответствует какому MAC-адресу. Однако, для корректного прохождения
через маршрутизатор, запрещающий широковещательные пакеты, можно
послать пакет по какому-то определённому адресу.Из минусов данной
технологии стоит отметить, что она:   должна поддерживаться аппаратно
(например, мой компьютер её не поддерживает, насколько мне известно);
как пишут некоторые пользователи, наблюдаются проблемы с
восстановлением работы, если пропадало напряжение в сети или компьютер
вынимали из розетки; является небезопасной, хотя бы даже из-за этого.
Понимаю, что вы мне ответите, что «жить вообще вредно, но это не
значит, что не надо жить».    В любом случае, я подумал, что создание
девайса, о котором пойдёт дальше речь, будет интересной затеей, так
как:   это более безопасно, чем Wake-on-LAN; можно установить даже на
устройства, не поддерживающие Wake-on-LAN; прошивка устройства
снабжена средствами восстановления связи, после пропадания
питания/перезагрузки; позволяет принудительно перезагрузить «зависший»
компьютер — удалённо; в принципе интересно, так как позволяет
реализовать новый девайс на esp32, в рамках растущего «интернета
вещей».   Почему я выше выделил пункт о принудительной перезагрузке: в
период активного «сидения на удалёнке» во время пандемии, мне
неоднократно приходилось сталкиваться с тем, что мой рабочий компьютер
зависал и работа останавливалась на целый день, потому что специалисты
IT службы — тоже на удалёнке. И им приходилось ехать в офис, чтобы
«клацнуть» reset моего компьютера! И это — международная компания с
множеством офисов…  ▍ Итак, приступим....  Некоторое время назад,
решение указанной проблемы было достаточно затруднённым: необходимо
было обладать достаточно высоким уровнем профессионализма и наличием
глубоких знаний в области электроники, чтобы собрать требуемое для
решения этой задачи устройство.   С появлением платформы Arduino,
данная задача существенно облегчилась, однако, она продолжала
оставаться достаточно неудобной в своей реализации, ввиду наличия
клубка проводов, соединяющих требуемые компоненты, либо, ввиду
необходимости покупки соответствующих wi-fi шилдов.   В текущее же
время, этот вопрос ещё более облегчился, из-за появления платы
espressif esp32. Для тех, кто не знает, это двухъядерный модуль,
содержащий множество необходимых для любого самодельщика свойств. В
рамках же данного проекта, нас будет интересовать наличие встроенного
wi-fi модуля.   Использование этой платы позволит нам легко и просто
построить требуемое устройство, не загромождая всё проводами и за
достаточно малую цену. Рискну предположить, что суммарная стоимость
компонентов нашего решения не превысит 350-400 руб.   Для того, чтобы
создать устройство, нам понадобится всего лишь четыре резистора, два
мосфет- транзистора и плата esp32.    А если точнее:    2 резистора на
10 кОм, мощностью на 1 ватт или меньше;  2 резистора на 100 Ом,
мощностью на 1 ватт или меньше; 2 мосфет-транзистора с логическим
уровнем IRLZ44NPBF; 1 модуль микроконтроллера esp32   Суть нашего
решения вкратце будет заключаться в том, что мы будем удалённо
«нажимать» на кнопку вкл/выкл на корпусе системного блока компьютера,
а также на кнопку перезагрузки, там же, на системном блоке. «Нажимать»
я специально написал в кавычках, так как фактически, мы будем замыкать
контакты указанных кнопок, не нажимая их физически.   По набору
компонентов, искушённый читатель сразу понял, что мы будем делать: с
помощью esp32 мы будем управлять ключами на основе мосфет-
транзисторов.     При использовании мосфет-транзистора нужно иметь в
виду один нюанс: транзистор должен открыться полностью, если этого не
произойдёт, то он в работе будет сильно греться и будет фактически,
работать в роли резистора.   В данном конкретном случае, это, конечно,
не так важно, так как мы будем коммутировать достаточно малые токи
кнопки включения/выключения и reset-a.   Кстати, весьма рекомендую к
прочтению хорошую статью про подбор мосфетов.   Конечно, можно не
напрягаться и взять релейные модули для ардуино:     Но это не наш
путь и вот почему: а) щелчки реле; б) наклёп контактов; в) высокое
энергопотребление релейным модулем.    Оно нам надо? Нет, оно нам не
надо :-)   Так как мы хотим сделать «всё красиво» — мы будем
использовать специальные мосфеты с логическим уровнем.    В рамках
данного проекта, я выбрал мосфет-транзистор IRLZ44NPBF. У него порог
срабатывания от 2 Вольт. То, что надо.   Как собрать ключ на мосфете —
можно почитать тут.   По поводу конкретных силовых исполнительных
устройств более-менее всё понятно. Однако нам ведь нужно ещё и каким-
то образом «рулить» esp32 внешнего интернета!   То есть, задача в
общем виде представляется следующей: некий интерфейс из внешнего
интернета, зная IP адрес esp32, может отдавать ей команды.   Однако,
подключение к устройству, находящемуся в сети за роутером, может стать
неудобством, ввиду, как минимум, смены IP адреса у управляемого
устройства, после каждой перезагрузки.    Да, вы скажете, что IP на
самом деле не меняется, он может поменяться, только если кто-нибудь из
домашних тоже подключится к сети, в тот момент, пока esp32
перезагружается, и ей придётся взять другой свободный IP.   Как бы там
ни было, но все эти частности не важны, так как данный вопрос можно
решить намного проще, чем выяснять какой текущий IP у платы и каким
образом его сообщить во внешний интернет: для этого мы будем
использовать протокол mqtt. Для тех, кто не сталкивался, вкратце можно
сказать, что протокол предназначен для интернета вещей, «умного» дома
и не только.   Использование протокола позволяет с лёгкостью обойти
проблему прохода за роутер (тут следует сделать оговорку, что мы
делаем допущение, что большая часть пользователей интернета, которая
выходит в сеть, используя персональные компьютеры, имеют дома wi-fi
точку доступа в виде роутера).  ❒ В нашем случае, использование
протокола будет выглядеть следующим образом:    используя смартфон и
интерфейс публичного mqtt-клиента, мы оставляем сообщение (цифру 0 или
1 или 2) в соответствующем топике (MoyComp/1 — переименуйте под себя),
который постоянно мониторится платой esp32. Пользуясь терминологией
протокола mqtt, можно сказать, что «esp32 подписана на соответствующий
топик», в котором наш смартфон будет оставлять сообщение, о
потребности совершения неких действий.   Значение отправляемых цифр:
0 — «выключить компьютер»;  1 — «включить компьютер»;  2 —
«перезагрузить компьютер»;   После того, как сообщение получено
платой, она выполняет определённые действия, и отчитывается в другом
топике, на который, в свою очередь, подписан смартфон, с которого мы
отправили задание. Таким образом, владелец смартфона узнает о том, что
плата получила задание и выполнила его.   Как работать с клиентом: при
запуске указанного выше mqtt-клиента — мы видим вот это окно. Ничего в
нём не меняем, жмём кнопочку «Connect»:    Далее, появится следующее
окно, где мы подписываемся на топик, в котором esp32 оставит сообщение
о выполнении задания. Для этого жмём Add new topic subscription:
Вводим топик и жмём «Subscribe»:     Топик, на который мы подписались
— появился справа, наверху:    Теперь, мы можем ввести топик, в
который надо отправить сообщение и собственно, сообщение. И жмём
«Publish». Сообщение уехало на esp32, и она отчиталась внизу, о
выполнении задания:    То есть, для работы всей системы нужны:
компьютер с установленной в него сборкой на базе esp32; точка доступа
wifi (домашний роутер); MQTT-брокер; публичный MQTT-клиент (который мы
запускаем на смартфоне).   Хорошая инфографика, о работе протокола
mqtt приведена на картинке ниже:   Источник картинки: wikihandbk.com
И работает оно так (текст оттуда же):   ESP32 #1 подключена к
светодиоду и считывает температуру с датчика DS18B20; ESP32 #2
подключена к кнопке, и нажатие на неё будет включать/выключать
светодиод, подключённый к ESP32 #1; ESP32 #2 подключена к LCD-дисплею
(передающему данные по I2C), на котором будут печататься данные о
температуре, полученные от ESP32 #1 ESP32 #1 подписана на топик
«esp32/led» и публикует данные о температуре в топик
«esp32/temperature»; При нажатии на кнопку, подключённую к ESP32 #2,
эта плата будет публиковать соответствующее сообщение в топик
«esp32/led», с помощью которого управляется светодиод, подключённый к
ESP32 #1;   Картинка напрямую не относится к нашему случаю, она
показывает пример, как это всё может работать, если использовать для
включения светодиод и кнопку.   Модифицируем её для нашего случая:
Прошивка проекта написана в Arduino IDE и доступна на моём гитхабе.
Пробежимся по основным моментам.   В своей работе мы будем
использовать публичный mqtt broker по адресу: broker.hivemq.com:
const char* mqtt_server = "broker.hivemq.com";  Вы можете использовать
любой другой — это вопрос исключительно предпочтений. Я выбрал этот и
он у меня заработал. А так как я обычно иду по пути наименьшего
сопротивления (в рамках парадигмы «и так сойдёт!» ), то искать что-то
иное не было смысла. Ибо любая минута поиска — воровала у меня время,
которое я мог бы с пользой провести, лёжа на диване, с думами о вечном
:-))).   Для начала мы в блоке изначальной инициализации переменных
указываем порт для подключения к mqtt брокеру, при необходимости — имя
пользователя и его пароль(или имя и пароль оставляем пустыми, если
брокер публичный — как в нашем случае):  #define mqtt_port 1883
#define MQTT_USER ""  #define MQTT_PASSWORD ""   Далее мы указываем
два топика, — один из которых для публикации статуса компьютера в
данный момент (то есть компьютер включён/выключен, или
перезагружается):  #define MQTT_SERIAL_PUBLISH_CH "/MoyComp/1/Status"
Именно туда esp32 выводит строгие и выверенные системные сообщения, о
происходящем с компьютером:   client.publish(MQTT_SERIAL_PUBLISH_CH,
"Ваш компьютер включён, господин!");
client.publish(MQTT_SERIAL_PUBLISH_CH, "Ваш компьютер выключен,
господин!"); client.publish(MQTT_SERIAL_PUBLISH_CH, "Ваш компьютер
перезагружается, господин!");   Другой, для получения сообщений из
внешнего интернета(сюда мы постим со смартфона цифры 0, 1 или 2, в
зависимости от которых выключается/включается/перезагружается
компьютер):  #define MQTT_SERIAL_RECEIVER_CH_1 "MoyComp/1"  Для
подключения мосфет-транзисторов, я использовал пины, под номерами 19 и
21. Вы можете использовать, в принципе, любые допустимые пины, хорошее
описание которых содержится по следующему адресу.   Из ещё одного
интересного момента можно рассмотреть следующие три переменные:  const
uint32_t comp_ON_period = 500; const uint32_t comp_OFF_period = 4000;
const uint32_t comp_Restart_period = 500;   В них мы задаем время в
миллисекундах, в течение которого наше устройство будет держать
нажатой соответствующую кнопку. Данные переменные вам нужно определить
самостоятельно, опытным путём(если мои значения не будут работать)-
для вашего конкретного компьютера, так как, вероятно, они могут
отличаться в вашем конкретном случае. В прошивке значения переменных
указаны для моего случая.   Ещё одним любопытным моментом, который
некоторые могут не знать, является то, что встроенный в esp32
светодиод привязан к пину, под номером 2. Я решил, что «инженерия
инженерией, но и красотень тоже должна быть». Поэтому наша esp-шка
будет мигать встроенным светодиодом:  const int LED = 2;  Теперь, что
касается питания нашей сборки на esp32: единственный более-менее
комфортный способ это осуществить,- запитать нашу сборку от дежурного
питания компьютера. Так как наша сборка потребляет совсем немного, её
подключение к дежурному питанию не должно вызвать проблемы с
невозможностью включения компьютера из-за просадки напряжения.   А
далее, когда компьютер включён — можно подключиться к нему, с помощью
предварительно настроенных программ удалённого администрирования,
удалённого рабочего стола и т.д. и т.п.   Ну, вот на этом кажется и
всё. Ещё раз только остановлюсь на том факте, что вся эта идея со
сборкой системы для удалённого управления компьютером была
продиктована не только, и не столько потребностью в доступе к файлам
(потому что, как альтернативу, можно купить в таком случае NAS), а
скорее даже необходимостью иметь возможность доступа к своему пулу
рабочих программ, которые установлены только на домашнем компьютере.
Успехов вам в сборке этого устройства!
