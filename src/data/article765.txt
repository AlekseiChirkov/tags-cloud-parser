Автор: kmoseenk
Дата: 2021-09-23T18:20:30.000Z
Название: Разбираемся со сборкой мусора в Java — Java2Blog
Теги: Блог компании OTUS, Java *
Текст:
В этой статье мы рассмотрим механизм сборки мусора на платформе
Java.Вместо теоретических объяснений я буду использовать схемы и
примеры.Память виртуальной машины Java (JVM) делится на три
части:Младшее поколение (young generation)Старшее поколение (old
generation)Метапространство — постоянное поколение (permanent
generation)Область младшего поколенияКак следует из названия, младшее
поколение — это область, в которой размещаются недавно созданные
объекты.Когда область младшего поколения заполняется, происходит малая
сборка мусора (minor GC).При выполнении малой сборки мусора из области
младшего поколения удаляются мертвые объекты.Если в младшем поколении
находится много мертвых объектов, малая сборка мусора выполняется
быстрее.Все операции малой сборки мусора являются событиями «остановки
мира» (stop-the-world), поэтому при их выполнении также
останавливаются потоки приложений.Давайте разберемся, как размещаются
объекты в области младшего поколения.Младшее поколение делится на три
части.Ниже приведена схема, иллюстрирующая области младшего и старшего
поколений.Все новые объекты размещаются в регионе Eden («Эдем»).Когда
регион Eden будет окончательно заполнен объектами, произойдет малая
сборка мусора. Все объекты, кроме мертвых и тех, на которые нет
ссылок, будут перемещены в один из регионов Survivor (регионы для
выживших объектов). Пусть в нашем случае все объекты будут перемещены
в регион S0.  Продемонстрируем это поведение на примере.Для этого
создадим класс, в котором будем генерировать короткоживущие
объекты.Запустим программу и проверим выделение памяти с помощью
Visual GC (плагин для VisualVM). Как видите, в S0 есть несколько
объектов. Как только регион Eden окончательно заполнился, все объекты,
на которые имелись ссылки, переместились в S1.Область старшего
поколенияИспользуется для размещения долгоживущих объектов.Обычно
больше, чем область младшего поколения.Когда область старшего
поколения окончательно заполняется объектами (или когда достигается
предварительно заданный порог), происходит крупная сборка мусора
(major GC) и освобождается память.Во многих случаях операции крупной
сборки мусора выполняются медленнее и менее часто по сравнению с малой
сборкой мусора.Как эти знания помогут в оптимизации работы с
памятью?Это зависит от характера приложения.Если у вас много временных
объектов, то будет много операций малой сборки мусора. Можно указать
аргумент XX:NewRatio=1, чтобы выделить 50 % кучи на младшее поколение
и 50 % — на старшее.По умолчанию NewRatio=2, то есть младшее поколение
занимает 1/3 всей кучи.Точно так же, если у вас очень много объектов-
долгожителей, может потребоваться увеличить размер области старшего
поколения, задав большее значение для NewRatio.Зачем нужны два региона
Survivor?Вероятно, вам интересно, зачем нам два региона для выживших
объектов. Мы используем два региона Survivor во избежание фрагментации
памяти. При каждом копировании объектов из региона Eden в регион
Survivor получается пустой регион Eden и один пустой регион
Survivor.Алгоритмы сборки мусораВ виртуальную машину Java встроены
несколько алгоритмов для организации областей младшего и старшего
поколений. Существует три типа таких алгоритмов.Последовательная
сборка мусораВ этом алгоритме вся сборка мусора осуществляется в одном
потоке. Такой алгоритм подходит для несложных приложений, работающих
на однопроцессорных компьютерах. Параллельная сборка мусораВ этом
алгоритме для сборки мусора задействуется несколько центральных
процессоров. Если при последовательной сборке мусора используется один
поток, то при параллельной сборке мусора используется несколько
потоков. Такой подход полезен при наличии достаточного объема памяти и
значительного количества ядер.Одновременная сборка мусораВ алгоритме
одновременной сборки мусора (concurrent mark sweep, CMS) для сборки
мусора используются потоки приложения. Такой подход полезен в
приложениях, которые имеют дело с наборами данных среднего или
крупного объема и требуют повышенного быстродействия. Для организации
областей младшего и старшего поколений можно использовать различные
алгоритмы сборки мусора, однако комбинировать между собой можно только
совместимые алгоритмы.Например, нельзя одновременно использовать
алгоритм параллельной сборки мусора для младшего поколения и алгоритм
CMS для старшего поколения, так как параллельный алгоритм не
обеспечивает синхронизацию, необходимую для CMS.С выходом Java 8 в
механизм сборки мусора было внесено множество изменений, о которых я
постараюсь написать в будущих статьях.Если у вас есть какие-либо
предложения по этой статье, пишите в комментариях.Материал подготовлен
в рамках курса «Подготовка к сертификации Oracle Java Programmer
(OCAJP)». Всех желающих приглашаем на открытый урок «Конструкторы и
блоки инициализации». На этом занятии мы: - Разберём конструктор на
запчасти;- Определим финалистов (финальные переменные);- Наведём
порядок (инициализации). >> РЕГИСТРАЦИЯ
