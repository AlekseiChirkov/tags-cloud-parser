Автор: SergeyNovak
Дата: 2021-10-07T14:16:01.000Z
Название: Управление RC машинкой 27mhz с компьютера
Теги: C++ *, GitHub, Программирование микроконтроллеров *, Схемотехника *,
DIY или Сделай сам
Текст:
Накопилось у меня некоторое количество радиоуправляемых игрушек, из
тех, которые покупать своим двум детям нельзя: один пульт управляет
всем в округе, никакого разделения ни по частотам, ни по кодам.
Одновременно играть не получится. У меня эти игрушки работают на
частоте 27mhz, но аналогичные могут работать на частотах 35, 40, 49
mhz по тому же простейшему протоколу, о котором и пойдет речь дальше.
Мне пришла мысль заменить пульт управления игрушки компьютером.
Основой для подобных мыслей послужил вот этот пост.Моя идея
заключалась в том, чтобы сделать USB девайс, на который можно
передавать с компьютера коды команд, а это устройство каждую команду
закодирует и выдаст в эфир RC-машинке. Первым этапом я решил убедиться
самостоятельно насколько описанное в вышеприведенном посте подходит к
моим RC-игрушкам. Как у автора поста, так и у меня, все игрушки
базировались на комплекте популярных микросхем RX-2 для приемника и
TX-2 для передатчика. Эти микросхемы имеют 5 входов для считывания
кнопок нажатия, которые они кодируют и передают в эфир на выходной
каскад. Таким образом, к примеру, нажатие кнопки "вперед" микросхема
кодирует следующим образом: заголовок, состоящий из 4 длинных
импульсов с заполнением 75% и сам код нажатия - десять коротких
импульсов с заполнением 50%. Список кодов коммандМое оборудование
использовало следующий набор команд:Forward: 10 pulsesReverse: 40
pulsesRight: 64 pulsesLeft: 58 pulsesForward/Left: 28
pulsesForward/Right: 34 pulsesReverse/Left: 52 pulsesReverse/Right: 46
pulsesНо было несколько пультов на 27 mhz, которые не работали или
работали не корректно с моими игрушками. В интернетах я нашел другой
набор команд для подобного оборудования (возможно, для другого набора
микросхем, не разбирался). Forward: 16 pulsesReverse: 40
pulsesForward/Left: 28 pulsesForward/Right: 34 pulsesReverse/Left: 52
pulsesReverse/Right: 46 pulsesИтак, я набросал код на C++ для
микроконтроллера Atmel AVR Attiny 2313 чтобы убедиться, что эта логика
работает. Выходной пин микроконтроллера я подключил к выходному
каскаду пульта игрушки чтобы не собирать радиочастотную схему
самостоятельно. Эту точку легко найти по пину 8 микросхемы TX-2:
именно он является выходом закодированных импульсов нужной длины,
которые подаются в этот каскад. Тут можно было бы даже просто взять
ножовку и выпилить все кнопки вместе с микросхемой  TX-2, но они для
подобных экспериментов не мешают поэтому оставил как есть.Связь с
компьютером через USBДля связи с компьютером я использовал библиотеку
vusb, набросав на универсальной плате обвес по следующей
схеме:Получился вот такой девайс:ОтладкаКод я написал, но вот работать
как нужно он отказался. Для отладки пришлось задействовать
запылившийся Sileae Logic Analyser. Так я смог заставить
соответствовать длины импульсов с моего контроллера тому, что выдавала
микросхема TX-2 и тогда все прекрасно заработало.На фото можно увидеть
визуально как кодируется сигнал "вперед", который имеет в своем теле
10 импульсов:4 длинных импульса заголовок: каждый ~1.3ms высокий
уровень and ~0.5ms низкий уровень сигнала с 75% заполнением: ~1.8ms
всего.10 коротких импульсов: каждый 0.5ms высокий and 0.5ms низкий.В
случае передачи другого кода заголовок остается тем же, а 10 коротких
импульсов заменяются на соответствующее другому коду количество.Код на
C++Для компьютера я сделал программу, которая в цикле читает
клавиатуру, кодирует и передает в USB контроллеру. Исходные коды для
микроконтроллера и для PC я выложил в общий доступ. Компилировал
используя gcc на Linux Gentoo, на Windows не проверял.Github
