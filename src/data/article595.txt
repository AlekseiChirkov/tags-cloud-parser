Автор: andrewrays
Дата: 2021-09-27T15:03:59.000Z
Название: Модельно-ориентированное проектирование на службе у специалиста по
электроприводу. Часть 2. Эксперименты
Теги: Блог компании ЦИТМ Экспонента, Алгоритмы *, Matlab *, Энергия и
элементы питания, Инженерные системы
Текст:
В предыдущей статье я рассказал, как создается модель векторного
управления СДПМ, и определил параметры двигателя по экспериментальным
данным. В этой статье мы заставим вращаться двигатель так, как нам
нужно, т.е. займемся настройкой контуров управления, и, разумеется,
проведем эксперимент, воспользовавшись сгенерированным из модели
кодом.Настройка регуляторовВо многих материалах, например [1, 2],
описывается классическая настройка регуляторов в структуре векторного
управления на оптимумы: контур тока настраивается на технический
(модальный) оптимум, а контур скорости – на симметричный.   Поскольку
формулы для коэффициентов регулятора известны, можно просто подставить
в них все значения и получить требуемый коэффициент. Но сколько
попыток настройки я не предпринимал, получающийся переходный процесс
по скорости меня не удовлетворял. После n-ой попытки я решил
воспользоваться готовой функцией, которая включена в пакет Motor
Control Blockset. Она также осуществляет настройку на оптимумы, но уже
точнее, поскольку в ней учитываются частоты дискретизации, на которых
работают контуры, а также частота ШИМ. Чтобы она подобрала параметры в
нее надо ввести: для токового контура коэффициент демпфирования, а для
скоростного – коэффициент оптимизации (на симметричный оптимум).
Правда аргументы этой функции – это структуры данных со строго
определенными полями, так что пришлось переписать свои параметры
двигателя и инвертора в эти поля. Приведу два переходных процесса,
получившихся после экспериментов с коэффициентами оптимизации
настройки регуляторов.Рис. 1. Переходные процессы по скорости при
различных настройках регуляторовКоэффициент демпфирования контура тока
равен 0.707. При таком значении коэффициент оптимизации контура на
технический оптимум равен 2. Я варьировал коэффициент оптимизации
контура скорости (1.5 и 2): чем он больше, тем быстродействие
уменьшается, зато снижается перерегулирование.  Теперь когда я
убедился, что модель алгоритма векторного управления работает
правильно, меня удовлетворили рассчитанные коэффициенты регуляторов,
настала пора переходить к переносу алгоритма на
микроконтроллер.Эксперименты Переход от обычной модели алгоритма к
модели, предназначенной для генерации из нее кода, был сопряжен с
двумя трудностями:Надо было понять, как программа будет «общаться» с
периферийными блоками микроконтроллера.Надо было решить проблему
точного определения положения ротора, поскольку в наличии есть только
инкрементальный (т.е. относительный) энкодер.Периферийные блокиПервая
проблема решается добавлением в модель специальных блоков пакета
поддержки. Так как я использовал микроконтроллер серии С2000 от Texas
Instruments, то я скачал прямо из MATLAB пакет специально для
него.Рис. 2. Страница пакета поддержки микроконтроллеров серии С2000 в
инструменте Add-On ExplorerМне понадобились следующие блоки:Блок
приема сигналов от энкодера. Он сам обрабатывает сигналы A, B и Z и на
выходе дает уже положение объекта управления. Также он может
автоматически вычислять скорость вращения. Но мне эта функция не
пригодилась, так как я поставил блок вычисления скорости из библиотеки
Motor Control Blockset. Я установил частоту работу блока (Sample time)
на 20 кГц и разрядность счетчика (Position Counter) на 16
разрядов.Рис. 3. Периферийный блок обработки сигналов с энкодера и
окно его параметров Блок настройки и получения информации из АЦП. В
этом блоке я настроил два канала АЦП (Input Channels), т.к. нам нужна
информация о токах двух фаз А и В, по какому внешнему прерыванию будет
происходить чтение датчика тока (SOCx trigger source) – по прерыванию
от блока ШИМ – и частоту работы АЦП (Sample time). Рис. 4.
Периферийный блок приема сигналов из АЦП и окно его параметровБлоки
ШИМ. В микроконтроллере реализовано несколько двуканальных блоков ШИМ.
Для управления инвертором мне потребовалось задействовать 3 канала
(для управления 6 ключами). Здесь есть огромное количество настроек,
на рассказ о которых ушла бы целая статья. Я лишь настроил вид ШИМ
(Counting mode) – центрированный (Up-down) для реализации SVPWM,
установил частоту (Timer period) на 40 кГц и включил прерывание для
АЦП.Рис. 5. Периферийный блок настройки модулей ШИМ и окно его
параметровБлоки передачи данных по UART. Для управления и отладки
программы я передаю и принимаю данные по последовательному порту в
компьютер. В качестве задатчика выступает специальная хост-модель, о
которой я расскажу дальше. В блоке приема данных (SCI Receive)
настраивается модуль UART, тип данных, приходящих в него, длина слова,
частота работы модуля и очередь FIFO на прием. Также можно добавить
идентификаторы в начало и в конец посылки. В блоке передачи (SCI
Transmit) можно выбрать только модуль, добавить идентификаторы и
настроить очередь FIFO на передачу. Рис. 6. Периферийный блок приема
данных их UART и окно его параметровРис. 7. Периферийный блок передачи
данных по UART и окно его параметровЗапуск в разомкнутом
контуреРешение второй проблемы потребовало добавления еще одного
режима работы - управление в разомкнутом контуре. Этот режим позволяет
разогнать двигатель до того момента, пока блок обработки сигналов от
энкодера не поймает сигнал полного оборота. С этого момента мы знаем
нулевое положение ротора и можем переключиться на векторное
управление. Алгоритм разомкнутого управления я подсмотрел в примере
Motor Control Blockset: Рис. 8. Модель управления двигателем в
разомкнутом контуреПоскольку добавился еще один режим, пришлось
включить в модель еще и планировщик задач, построенный с помощью
диаграммы Stateflow:Рис. 9. Планировщик задач для управления режимами
работыВ нем находятся четыре основных состояния: STANDBY - двигатель
не вращается, OPENLOOP - двигатель вращается в разомкнутом контуре,
CLOSEDLOOP - двигатель вращается в замкнутом контуре, CALIBRATION -
калибровка энкодера.Прежде чем начать управлять нашим двигателем в
замкнутом контуре, нам необходимо «пройти» через состояние OPENLOOP.
Когда мы поймали сигнал полного оборота, сигнал ChangeFlap принимает
значение логической единицы, и возможен переход в состояние
CLOSEDLOOP. Для того чтобы просто откалибровать датчик положения можно
перейти в состояние CALIBRATION.Итоговая модель алгоритма управления
выглядит так:Рис. 10. Модель системы управления электродвигателем,
предназначенная для кодогенерацииОна состоит из следующих
подсистем:Hardware Init. В ней располагается алгоритм калибровки АЦП
при инициализации программы.Heartbeat LED. Вспомогательная функция,
которая сигнализирует нам, что программа работает на микроконтроллере.
Для этого служит мигающий диод.Serial Receive. В ней располагается
блок SCI Receive и выполняется обработка данных, принятых из UART.
Рис. 11. Подсистема Serial ReceiveSensors Signals Processing. Она
объединяет две подсистемы Phase Currents Computation и Position and
Speed Computation, которые описаны в предыдущей статье.Control System.
В ней располагаются алгоритмы управления двигателем в разомкнутом и
замкнутом контурах, а также планировщик задач.Inverter Driver. Она
включает модули настройки ШИМ.Рис. 12. Подсистема Inverter
DriverSerial Transmit. В ней располагается блок SCI Transmit и
выполняется обработка данных, передаваемых через UART.Как я уже
говорил, я передаю и принимаю данные с помощью такой хост-модели:
Рис. 13. Хост-модельС ее помощью я формирую пакет данных, в котором
кодирую требуемый режим управления, скорость и номера сигналов,
которые я хочу передавать в компьютер (скорость, положение, токи и
т.д.). Модель содержит несколько специальных блоков: Host Serial
Setup, Host Serial Receive и Host Serial Transmit (он находится в
подсистеме Serial Send). С помощью первого блока я настраиваю основные
параметры модуля UART: номер порта, скорость передачи, количество
стоповых бит и т.д.Рис. 14. Окно параметров блока Host Serial SetupВ
блоке Host Serial Receive я указываю тип данных, передаваемых через
порт, из размер, идентификационные байты и частоту работы модуля-
приемника и другие параметры.Рис. 15. Окно параметров блока Host
Serial ReceiveВ последнем блоке указывается номер порта, а также можно
добавить идентификационные байты.Рис. 16. Окно параметров блока Host
Serial TransmitРезультатыПроведя эксперимент и сравнив полученные
данные с результатами моделирования, я получил практически точное
совпадение переходных процессов по скорости (отличие составляет менее
2%). Рис. 17. Сравнение переходных процессов по скоростиОтличие эпюр
тока фазы А в эксперименте и при моделировании больше: около 7% в
установившемся процессе.  Рис. 18. Сравнение эпюр токов фазы
АЗаключениеВ этой и предыдущей статьях я надеюсь, что смог
продемонстрировать, что МОП - достаточно мощный инструмент в вопросах
проектирования системы управления трехфазным двигателем.Я создал
адекватную модель объекта управления (трехфазного двигателя),
промоделировал алгоритм векторного управления, настроил регуляторы и
автоматически сгенерировал код для микроконтроллера из модели. Увидел,
что результаты, полученные во время моделирования, практически
совпадают с экспериментальными данными.СсылкиОптимизация контуров
регулирования систем электропривода по симметричному оптимуму. Н.В.
Кояин, О.П. Мальцева, Л.С. УдутОптимизация контуров регулирования
систем электропривода по типовым методикам. Н.В. Кояин, О.П. Мальцева,
Л.С. Удут
