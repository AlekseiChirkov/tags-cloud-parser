Автор: enragez
Дата: 2021-09-27T07:43:30.000Z
Название: Как мы с Ext JS 3.4 на Ext JS 7.1 переходили
Теги: Блог компании БАРС Груп, JavaScript *, Программирование *, Библиотека
ExtJS/Sencha *
Текст:
Привет! Меня зовут Андрей Ивойлов, я ведущий разработчик и тимлид в
команде платформы «Своды» «БАРС Груп». Мы разрабатываем платформу для
сбора, анализа и консолидации отчетности «Своды». Разработка платформы
началась в далеком 2006 году, а самый первый веб-интерфейс для неё был
написан в 2009 году.Но в этой статье хотелось бы подробнее познакомить
вас с Ext JS и рассказать, почему мы работаем именно на этом
фреймворке. Ext JS - это проприетарный JavaScript-фреймворк для
построения SPA-приложений от компании Sencha. В 2011 году Sencha
выпустили Ext JS 3.4. После чего «Своды» перешли на эту версию
фреймворка и на долгие годы остались с ней. Интерфейс «Сводов» на Ext
JS 3.4Опережая вопросы. У нас небольшая команда, которая состоит из
пяти разработчиков, двух тестировщиков и одного системного аналитика.
При переходе с Ext JS 3.4 на Ext JS 7.1 мы решили не привлекать других
специалистов, ведь были уверены, что справимся своими силами.Спойлеры!
Еще мы поделимся с вами классной самодельной фичей, так что советуем
прочитать до конца. Будет интересно! Зачем мы решили обновить Ext
JS?Ответ прост – посмотрите на скриншот выше. UI системы сильно
устарел, поэтому перед нами была поставлена задача реализовать новый
UI, а в связи с глобальными изменениями дизайна было решено обновить и
стек технологий. Почему все еще Ext JS в 2021 году?Первая причина
заключается в том, что наши разработчики предпочитают backend (.NET),
но у всех есть опыт работы с Ext JS, полученный за счет поддержки
платформы. Ext JS не требователен к знанию html, на нем не нужно
писать разметку.Вторая причина связана со спецификой продукта - в
системе есть много гридов и большие требования к возможностям, которые
эти гриды должны предоставлять пользователям. У Ext JS такие гриды
есть из «коробки». В целом у Ext JS хороший набор готовых компонентов
практически на все случаи жизни.Исходя из этого, мы приняли решение не
менять Ext JS на Angular/React/Vue/«ваш любимый фреймворк» или
библиотеку. Смена стека потребовала бы расширения компетенций
разработчиков или увеличения штата разработки. Также понадобилось бы
время для реализации базовых возможностей, требуемых от интерфейса
системы, либо покупка дополнительных наборов готовых компонентов.Фичи,
которые получаем при обновлении с 3.4 до версии 7.1:MVC и MVVM
архитектуру приложения.CSS и систему тем для приложения с возможностью
переключения их из интерфейса. В том числе большой набор базовых тем,
даже в стиле material design.Увеличенный набор базовых компонентов –
tagfield, virtual scroll в гридах. Новый тулинг – sencha cmd, sencha
themer.Гибкую структуру приложения с возможностью расширения под нужды
конкретного проекта, реализуемого на нашей платформе.Поддержка touch
девайсов.Приступаем к разработкеВ начале совместно с командой
дизайнеров занимаемся созданием дизайн-системы, проработкой UX и
параллельно рисуем макеты практически всех экранов системы в
Figma.Когда макеты готовы, то приступаем к следующему этапу –
реализация темы для приложения. Тема в приложении Ext JS – это пакет,
содержащий в себе SCSS и JS файлы, также в него могут быть включены
дополнительные ресурсы (шрифты, картинки). В пакете описываются все
базовые стили для компонентов, которые есть в Ext JS, могут
содержаться оверрайды компонентов на JS. Мы решили, что нам нужна
базовая тема, от которой в дальнейшем можно будет отталкиваться при
реализации других, для этого у Ext JS есть поддержка наследования тем.
Также было решено, что в этой теме у нас будут все оверрайды, которые
необходимы для реализации требований дизайн-системы.Пишем эту тему и
тестируем её на проекте-песочнице (простая html, на которой
расположено большинство стандартных компонентов, используемых в
системе).Ext.define('theme_sandbox.view.main.Main', {     extend:
'Ext.container.Viewport',     layout:'border',     xtype: 'app-main',
scrollable:true,     requires: [         'Ext.plugin.Viewport',
'Ext.window.MessageBox',         'Ext.window.Window',
'Ext.ux.form.SearchField',         'Ext.panel.Panel',
'Ext.toolbar.*',         'Ext.tree.Panel',
'Ext.container.ButtonGroup',         'Ext.form.*',
'Ext.tab.*',         'Ext.slider.*',         'Ext.layout.*',
'Ext.button.*',         'Ext.grid.*',         'Ext.data.*',
'Ext.util.*',          'Ext.perf.Monitor'     ],     initComponent:
function(){         var time = Ext.perf.getTimestamp();         var
maskedPanel = this.getMaskedPanel();          Ext.apply(this, {
items:[{                 region:'center',                 scrollable:
true,                 items:[{                     xtype:'container',
layout: 'absolute',                     width: 9999,
height: 9999,                     items:[
this.getBasicPanel(), // Ext.panel.Panel
this.getCollapsedPanel(), // Ext.panel.Panel collapsed
maskedPanel, // Ext.panel.Panel with mask on it
this.getFramedPanel(), // Ext.panel.Panel framed
this.getCollapsedFramedPanel(), // Ext.panel.Panel framed and
collapsed                         this.getBasicWindow(), //
Ext.window.Window                         this.getPanelWithToolbars(),
// Ext.panel.Panel with Ext.toolbar.Toolbar
this.getFormWidgets(), // Ext.form.Panel with default tools
this.getBorderLayout(), // Ext.panel.Panel with border layout
this.getGrid(), // Ext.grid.Panel
this.getAccordion(), // Ext.panel.Panel with accordion layout and
trees inside                         this.getScrollingTabs(), //
Ext.tab.Panel with overflow and scrolling
this.getPlainTabs(), // Ext.tab.Panel
this.getDatePicker(), // Ext.picker.Date
this.getProgressBar(), // Ext.ProgressBar
this.getFramedGrid(), // Ext.grid.Panel framed
this.getResizer() // Ext.panel.Panel with resizer
]                 }]             }]         });
setTimeout(function() {             if (maskedPanel) {
maskedPanel.setLoading({                     msg: 'Загрузка...',
useTargetEl: true                 });             }
Ext.QuickTips.init();         }, 2000);          time =
Ext.perf.getTimestamp() - time;         Ext.log('total time: ' +
Math.round(time));
theme_sandbox.view.main.Main.superclass.initComponent.call(this);
},      /* дальше реализация методов создающих компоненты */ });Уже на
этом этапе появились подозрения, что дизайн, который нам предлагается,
будет с трудом "натянут" на возможности Ext JS. Но даже в этой
ситуации Ext JS оставался для нас самым правильным выбором фреймворка.
Grid и TreeGrid в новом дизайне на Ext JS 7.1Toolbar навигации и
TabPanel в новом дизайне на Ext JS 7.1После этого наступил этап
реализации интерфейса реального приложения. Вначале изменения
коснулись интерфейса, который отображается сразу после авторизации
пользователя. Параллельно несколькими разработчиками велась работа по
осуществлению функционала кнопок меню навигации и всего, что
происходит за ними.   На этом этапе начинаются трудности, которые мы
ожидалиExt JS тяжело кастомизировать под некоторые бизнес-требования,
потому что фреймворк полностью контролирует верстку компонентов.
Например, одна из фичей, которую необходимо было реализовать – это
группировка строк в гридах. В обычных гридах Ext JS группировка
реализована с большими возможностями по расширению функционала, а вот
в гридах с virtual scroll она не поддерживается. Эту группировку
пришлось реализовывать с нуля, переопределяя приватные классы и
методы. Такие оверрайды непременно приводят нас к сильной связанности
с версией фреймворка и осложняют его обновление в будущем.Также
практически любая кастомизация скорее всего приведет к неожиданному
поведению.  В нашем случае большинство багов, которые мы нашли в
результате тестирования нашего нового интерфейса, связаны именно с
тем, что мы оверрайдили внутренности Ext JS. А без этого было
невозможно реализовать бизнес-требования к продукту, которые Ext JS не
поддерживает из «коробки».  Неожиданное поведение при кастомизации По
правилам нашей дизайн-системы в интерфейсе могут быть кнопки без
текста, состоящие только из иконки, а также кнопки только с текстом.
Минимальная ширина этих кнопок ограничена дизайн-системой, и мы пишем
простой код, который должен решить эту
задачу:Ext.define('Svody.theme.button.Button', {     override:
'Ext.button.Button',     scale: 'medium',     initComponent(){
if (!this.text){             this.addCls('only-icon-button');
this.minWidth = 32;         }         else {             this.minWidth
= 71;         }         this.callParent(arguments);     },     /*
При обновлении текста после создания кнопки корректируем стиль кнопки
*/     updateText(text){         if (text){
this.removeCls('only-icon-button');             this.setMinWidth(71);
}         else {             this.addCls('only-icon-button');
this.setMinWidth(32);         }                  return
this.callParent([text]);     } });После чего получаем неожиданное
поведение:Ext.define('Ext.tab.Tab', {     extend: 'Ext.button.Button',
alias: 'widget.tab',     /* дальше остальной код из исходника ExtJs */
})Выясняется, что вкладки в TabPanel компоненте Ext JS реализованы как
кнопки, и наш оверрайд внезапно ограничивает минимальную ширину
заголовка вкладки.  Не спешите оверрайдить дефолтное поведениеЕсли для
реализации абсолютно новой системы вы выбрали Ext JS в качестве
фреймворка – не спешите оверрайдить дефолтное поведение на первых
этапах разработки, даже если этого требует UX/UI или бизнес. В
условиях, когда у вас в команде нет опытных frontend-разработчиков,
знакомых с Ext JS, правильным решением будет отказываться от
оверрайдов (не считая багфиксов, которые в «экстах» тоже встречаются).
В дальнейшем, если у вас осталось время – можно изменять поведение Ext
JS с помощью оверрайдов, писать свои компоненты с нуля, хорошо
продумывать поведение и тестировать их. В нашем случае система уже
обросла огромным количеством фич и поведением, которые мы не могли
выбросить.Еще одним примером такой фичи стал Pivot Grid. В базовой
комплектации Ext JS такого компонента нет, он находится в отдельном
пакете компонентов Premium, который нужно покупать отдельно. В нашей
системе есть небольшой модуль аналитики, для которого пришлось
реализовать этот компонент с нуля. Самодельный PivotGridЕще одна
проблема, с которой мы столкнулись в процессе разработки не относится
к Ext JS, она скорее организационная. Мой вам совет. Хорошо продумайте
макеты и весь UX системы до начала разработки. После утверждения
макетов не вносите в них изменения. Опыта реализации интерфейса с нуля
у нас практически не было, поэтому мы и «наступили на эти грабли». Это
привело к преобразованию не только дизайн-системы, но всей системы в
целом и повторному тестированию.Что было получено в итоге: Современный
интерфейс, который было бы невозможно реализовать на старой версии Ext
JS.Возможность быстро реализовывать новые темы для интерфейса,
например, темная тема была реализована примерно за 60 человеко-
часов.Удобную архитектуру frontend-приложения – MVC + MVVM.Улучшенные
возможности по расширению и изменению функционала платформы под нужды
конкретных заказчиков. Теперь можно с легкостью добавить кнопку в
интерфейс или изменить поведение кнопки для разработчика проекта,
реализованного на базе платформы. Ускоренную работу интерфейса в тех
местах, где появился virtual scroll вместо обычного. Обновлённый стек
технологий. Планируется реализация сборки через webpack поверх Sencha
CMD. Удобные механизмы изменения интерфейса под разные проекты с
помощью добавления проектного кода без участия разработчиков
платформы. Интерфейс «Сводов» на Ext Js 7.1Интерфейс «Сводов» на Ext
Js 7.1 в темном оформленииИ напоследок одна из полезных самодельных
фич, которой нам не стыдно поделиться.Самодельная фича В Ext JS есть
стандартный механизм Ajax-запросов - Ext.Ajax. Его использование
выглядит примерно вот таким образом:Ext.Ajax.request({     url:
'Designer/HasPermission',     method: 'GET',     success:
function(response){         console.log('request success');     },
failure: function(response){         console.log('request failed');
} })Также в Ext JS есть другой RPC-механизм - Ext.Direct. Он давно
использовался в нашей системе, мы привыкли к нему и решили оставить
после обновления фреймворка.Суть этого механизма в том, что при
запуске Ext JS приложения server-side предоставляет описание своего
API в виде JSON, например:const directApi = {     "descriptor":
"Svody.RemotingAPI",     "url": "/svody/DirectRouter/Index",
"type": "remoting",     "actions": {         "Designer": [{
"name": "HasPermission",             "len": 0         }],
"Job": [{             "name": "CancelJob",             "len": 2
}],         // etc.     } };Где url – это единая точка входа всех
запросов на backend. Actions – это список контроллеров (у нас backend
на ASP.NET Core), которые могут обрабатывать запрос внутри описания
контроллера – массив экшенов и количество параметров этого
экшена.Далее в коде вызывается регистрация этого объекта в качестве
Ext.Direct.Provider:Ext.direct.Manager.addProvider(directApi)После
этого вызов любого описанного в провайдере экшена можно выполнить с
помощью такого кода:  Designer.HasPermission(function(response){
if (response.success){         console.log('request success');     }
else {         console.log('request failed');     } }, scope)На мой
взгляд, это удобнее, чем стандартный механизм Ajax-запросов.Но мы
пошли дальше. Теперь в Sencha CMD нам доступна транспиляция, а еще
было принято решение отказаться от поддержки старых браузеров (прощай
IE, скучать не будем) – с этого момента мы можем использовать
async/await.По итогу была реализована вот такая
обертка:Ext.define('Svody.shared.utils.DirectAsync', {     statics: {
init: function(directProvider){             let actions =
directProvider.actions,                 namespace =
directProvider.namespace,                 Manager =
Ext.direct.Manager;             for (let action in actions) {
if (actions.hasOwnProperty(action)) {                     let
actionAsync = `${action}Async`;                     let clsAsync;
if (directProvider.disableNestedActions) {
clsAsync = namespace[actionAsync];                         if
(!clsAsync) {                             clsAsync =
namespace[actionAsync] = {};                         }
}                     else {                         clsAsync =
directProvider.getNamespace(namespace, actionAsync);
if (!clsAsync) {                             clsAsync =
directProvider.createNamespaces(namespace, actionAsync);
}                     }                      let methods =
actions[action];                     for (let i = 0; i <
methods.length; i++) {                         let method =
methods[i];                         let methodName = method.name;
let handler = Manager.remotingMethods[`${action}.${methodName}`];
clsAsync[method.name] = function(){                             let
handlerArgs = arguments;                              return new
Ext.Promise(function(resolve, reject) {
let args = Array.prototype.slice.call(handlerArgs);
let hasCallback = false;                                 if
(args.length) {                                     for (let argIndex
= 0; argIndex < args.length; argIndex++) {
let arg = args[argIndex];                                          if
(Ext.isFunction(arg)) {
hasCallback = true;                                             break;
}                                     }
}                                                                  if
(!hasCallback){
args.push(function(response){
if (response === undefined || response === null){
reject(response);                                         }
else{                                             resolve(response);
}                                     });
}                                 handler.apply(this, args);
});                         };                     }                 }
}         }     } });Теперь мы можем делать вот так:  const response =
await DesignerAsync.HasPermission(); if (response &&
response.success){     console.log('request success'); } else {
console.log('request failed'); }Какие выводы?Ext JS отлично подходит
для решения наших задач: он все также хорош для enterprise приложений,
особенно там, где много гридов. Также он подойдет для команд
разработки, которые не хотят или не могут верстать. Улучшился тулинг
вокруг Ext JS, появилась sencha cmd, тулинг для создания тем и базовый
набор тем. Добавлена поддержка подключения пакетов npm и сборки через
webpack. MVC и MVVM ускорили разработку и упростили поддержку своих
компонентов. Есть и минусы. Да, теперь не нужно верстать, но
реализация любого отклонения от стандартного поведения «экстов»
приводит либо к ошибкам, либо к неожиданному поведению. Вывод:
изменения нужно вносить очень осторожно.
