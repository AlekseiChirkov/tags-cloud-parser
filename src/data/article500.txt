Автор: FirstJohn
Дата: 2021-09-29T07:00:04.000Z
Название: База данных на SharedPreferences — Android Kotlin
Теги: Блог компании FirstVDS, Программирование *, Разработка под Android *,
Kotlin *
Текст:
Для хранения большого количества информации в Android используется
DataBase (SQLite, FireBase и т. п.), а для простого хранения настроек
— SharedPreferences. Вопрос, можно ли использовать SharedPreferences
как своего рода Базу Данных и как это сделать? Статья написана об
учебном проекте, повторять такое на проде нельзя, как минимум это
небезопасно. Намеренно используется не самая лучшая реализация тех или
иных вещей, чтобы можно было подискутировать в комментариях.  Зачем
всё это? Зачем?  Наверное, в вашей голове возник вопрос: «В каких
ситуациях может понадобиться использование SharedPreferences, если
абсолютно всё можно хранить в Базе Данных?»   Отвечаю: и правда,
абсолютно всю информацию можно хранить в таком виде. Иметь таблицу с
настройками приложения (например, тёмная тема: вкл/выкл), а в другой
таблице хранить ту самую информацию, которую отображает само
приложение. Но эффективно ли это? Если информации много и SQL запросы
помогают вам, то да, но не стоит забывать, что Базы Данных в
большинстве случаев являются сложным механизмом, из-за чего
производительность вашего приложения может быть снижена. Если
информации не так много, то гораздо выгоднее использовать
SharedPreferences.  Краткая теория, как использовать SharedPreferences
Чтобы получить экземпляр класса SharedPreferences, в коде приложения
используются два метода:   getPreferences() — внутри активности, чтобы
обратиться к определённому для активности предпочтению,
getSharedPreferences() — внутри активности, чтобы обратиться к
предпочтению на уровне приложения.   Все эти методы возвращают
экземпляр класса SharedPreferences, из которого можно получить
информацию с помощью ряда методов:   getBoolean(String key, boolean
defValue), getFloat(String key, float defValue), getInt(String key,
int defValue), getLong(String key, long defValue), getString(String
key, String defValue).   По умолчанию используется MODE_PRIVATE —
только приложение имеет доступ к настройкам:   MODE_APPEND —
присоединяет новые настройки к существующим,
MODE_ENABLE_WRITE_AHEAD_LOGGING, MODE_MULTI_PROCESS,
MODE_WORLD_READABLE — позволяет другим приложениям читать настройки,
MODE_WORLD_WRITEABLE — позволяет другим приложениям записывать новые
настройки.   Эти файлы настроек хранятся в каталоге:
/data/data/имя_пакета/shared_prefs/имя.xml.  Начинаем эксперимент
Представим такой проект: на вход поступает json файл, в нём хранится
информация о валютах (имя, стоимость и т. д.). Нам необходимо
сохранить эти данные и при перезапуске приложения показать их, не
читая json (все данные взяты из нашей БД). Возможные взаимодействия с
карточкой валюты: изменение любого поля.   Все исходники вы сможете
найти на GitHub в конце статьи.   Создадим самый обыкновенный класс и
передадим ему в аргументы context для SharedPreferences. (Хотел бы
услышать ваше мнение по поводу классов. Какой класс вы бы предпочли
использовать в данной ситуации?)  class DataBasePreferences(var
context: Context)  Мы создадим два пространства. Первое будет хранить
информацию о нашей DB и будет статично по своей размерности. В нём
будет храниться количество наших карточек с валютами. Второе поле
должно хранить те самые карточки, а значит — уметь динамически
изменять свой размер.   Как оно будет работать? SharedPreferences
хранит данные, как, грубо говоря, Map (ключ->значение), и вся
информация находится в «таблице данных». Благодаря имени данной
таблицы мы и будем передвигаться по карточкам. Новое имя таблицы =
новая карточка. Таблицы мы будем называть цифрами, они будут выполнять
роль их id. Так будет намного проще передвигаться по ним.    Создадим
и проинициализируем глобальные переменные класса:  private var prefs:
SharedPreferences private val prefsSetting =
context.getSharedPreferences("databaseInfo", Context.MODE_PRIVATE)
private var editor: SharedPreferences.Editor private val
editorSettings = prefsSetting.edit() private var indexNow = 0  init {
prefs = context.getSharedPreferences(getSizeInt().toString(),
Context.MODE_PRIVATE)     editor = prefs.edit()  А вот и первая наша
функция. Она позволяет узнать размер 2 поля (сколько таблиц оно
содержит):  fun getSizeInt(): Int {     return
prefsSetting.getInt("size", 0) }  Если поле не создано, то
возвращается 0.    Геттер создали, теперь время сеттера. Для этого
создадим две функции:  private fun sizeUp() {
editorSettings.putInt("size", getSizeInt() + 1).apply() }  private fun
sizeDown() {     editorSettings.putInt("size", getSizeInt() -
1).apply() } ВНИМАНИЕ: если в конце не написать .apply(), изменения не
сохранятся!  Вторая область  Теперь перейдём ко 2 области, нам
необходимо уметь перемещаться по нашим «таблицам», для этого реализуем
такую функцию:  private fun updatePrefs(index: Int) {     if (indexNow
!= index) {         indexNow = index         prefs =
context.getSharedPreferences(index.toString(), Context.MODE_PRIVATE)
editor = prefs.edit()     } }  Стоит немножко объяснить код. В
аргументах мы принимаем название таблицы (её порядковый номер), после
чего можно заметить проверку, которая сравнивает текущий порядковый
номер таблицы с полученным, в случае если они не равны, происходит
переприсвоение текущего названия таблицы и её открытие. Доступ к
чтению таблицы мы получаем благодаря глобальной переменной prefs, а к
редактированию — editor.  Добавление карточек к БД  Что же, думаю,
можно перейти к заполнению нашей таблицы:  fun addJSONObject(_input:
JSONObject) {     sizeUp()     updatePrefs(getSizeInt())
setId(_input.getString("ID"))
setNumCode(_input.getString("NumCode"))
setCharCode(_input.getString("CharCode"))
setNominal(_input.getString("Nominal"))
setName(_input.getString("Name"))
setValue(_input.getString("Value"))
setPrevious(_input.getString("Previous")) }  На вход мы получаем JSON
объект, после чего увеличиваем количество всех наших таблиц, открываем
новую таблицу и используем сеттеры. Ниже представлен код одного из
таких сеттеров:   fun setId(_input: String, _id: Int? = -1) {
_id?.let {         if (_id != -1)             updatePrefs(_id)
editor.putString("ID", _input).apply()     } }  Тут без объяснений не
обойтись. Функция принимает 2 аргумента, причём последний аргумент
является необязательным (если его не изменять, он по умолчанию будет
равен -1), а также может хранить null. Дальше идёт конструкция
_id?.let{}, она позволяет запустить фрагмент кода (в фигурных
скобках), если переменная не равна null. После чего идёт проверка,
стандартное ли значение 2 аргумента. Если на вход мы получили номер
таблицы -> открыть нужную таблицу. В конце присваиваем новое значение
по ключу «ID» и не забываем применить все изменения с помощью
.apply(). Для чего мы добавили возможность переменной _id хранить
null, объясню чуть позже.   Подобные сеттеры нужно создать для каждого
ключа JSON объекта.   Чтение карточки  Сеттеры отдельных ключей есть,
а это значит, что наша самодельная БД уже умеет сохранять информацию,
осталось научить её считывать. Ниже приведён пример одного из
геттеров:  fun getId(_id: Int? = -1): String? {     _id?.let {
if (_id != -1)             updatePrefs(_id)         return
prefs.getString("ID", "").toString()     }     return null }  Мы можем
наблюдать, как функция может принимать пользовательское имя таблицы,
так и использовать значение по умолчанию. Если пользователь не вводил
имя таблицы, то информация будет взята из текущей.  Поиск карточки
Замечательно, наша БД на SharedPreferences умеет сохранять и выводить
данные, правда осталась одна нерешённая проблема. Предположим, что при
работе с приложением пользователь захочет изменить определённую
карточку, нажав на неё, для этого у нас уже существуют сеттеры, но
откуда нам знать, какую именно таблицу нужно открыть для работы?
Предположим, у нас есть возможность получить какую-нибудь информацию с
карточки, например, сокращённое имя валюты. Получается, нам необходимо
пройтись по всем существующим таблицам, найти совпадение и вывести
название данной таблицы. Это долгая операция, поэтому таких ситуаций
лучше не создавать, например, пусть каждая карточка в интерфейсе будет
хранить свой локальный номер, который будет совпадать с названием
таблицы, но если такой возможности нет, то в бой идёт наша новая
«тяжёлая» функция:  fun searchIdCardByNumCode(_input: String): Int? {
for (index in 1..getSizeInt()) {         updatePrefs(index)         if
(_input == getNumCode()) {             return index         }     }
return null }  В случае если совпадений не найдено, будет возвращено
null. Поскольку данная функция, скорее всего, будет использована в
комбинации с сеттерами и геттерами, мы и добавили в них поддержку
null. Данная функция ищет совпадения по NumCode значению, и нам ничто
не мешает сделать аналогичные функции для оставшихся ключей.  DataBase
на SharedPreferences в действии  Перейдём в наш MainActivity и
создадим экземпляр нашего класса, наименовав его db. После чего
получим JSONobject из памяти Android и в функции «createDB» запишем
всю интересующую нас информацию в нашу db, затем прочитаем некоторую
информацию карточки в функции readInfoDB, выпишем её, следом изменим
внутри лежащую информацию с помощью функции editInfoDB и снова
распечатаем результаты:  class MainActivity : AppCompatActivity() {
private lateinit var db: DataBasePreferences      override fun
onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)          db =
DataBasePreferences(this)         createDB()         val idTable =
db.searchIdCardById("R01035")         readInfoDB(idTable)
editInfoDB(idTable)         readInfoDB(idTable)     }      private fun
createDB() {         val jsonRoot =
JSONObject(resources.openRawResource(R.raw.daily_json)
.bufferedReader().use { it.readText() })         val currency =
jsonRoot.getJSONObject("Valute")         val keys = currency.keys()
for (index in 0 until currency.length())
db.addJSONObject(currency.getJSONObject(keys.next()))     }
private fun editInfoDB(_id: Int?) {         _id?.let {
db.setCharCode("LP", _id)
db.setName("@lonely_programmer")//Заметьте, я могу не указывать id
явно, т.к. работаю с одной карточкой             db.setNumCode("1234",
_id)         }     }      private fun readInfoDB(_id: Int?) {
_id?.let {             Log.d("checkDBCHARCODE: ",
db.getCharCode(_id).toString())             Log.d("checkDBNAME:
",db.getName(_id).toString())             Log.d("checkDBNUMCODE:
",db.getNumCode(_id).toString())         }     } }  Поздравляю, оно
работает! (P.S. lateinit в Kotlin советуют не использовать)    Если
вдруг Logcat не работает, попробуйте его перезагрузить. (Обычно такое
происходит из-за нехватки мощности компьютера).    Итог  Какие могут
возникнуть трудности в будущем?    Удаление карточки-таблицы, т.к. это
не связный список, при удалении все элементы будут сдвигаться, а это,
в свою очередь, долгий процесс. Добавление карточки не в конец списка
приведёт к сдвигу всех элементов. Нельзя наглядно увидеть, что
хранится в Базе Данных. При стирании кэша приложения всё сотрётся. При
замене всех параметров таблицы есть вероятность её потерять, т.к.
неизвестно, по каким параметрам искать таблицу. Очень рискованно.
Это был весёлый и интересный эксперимент, который и правда сработал.
Можно ли это использовать на проде? Конечно же, нет, напомню, что это
учебный проект и такой способ хранения информации небезопасен, но,
надеюсь, эта статья показала вам, что при должном желании возможно
абсолютно всё. В этом и есть прелесть программирования, ты можешь
реализовать одну и ту же вещь разными способами. Если эта тема кажется
вам интересной, дайте знать, сделаю 2 часть, где мы добавим много
действительно крутых функций от старших братьев и полностью перепишем
нашу DataBase. Например, используем шифрование, связной список и дадим
возможность создавать пользовательские пространства. Обещаю, будет
безумно интересно. Не забывайте делиться своим мнением о данной
задумке и статье в принципе.    Если у вас есть замечания по коду —
пишите, обсудим в комментариях. P.S. — исходники
